<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, December 21, 2020, 1:11 PM -->
<!-- MuClient version 5.06 -->

<!-- Plugin "StreetRepairHelper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="StreetRepairHelper"
   author="Kloke"
   id="885c6af8234c00185184147a"
   language="Lua"
   purpose="Helps with fixing streets"
   date_written="2020-12-21 13:07:50"
   requires="5.06"
   version="1.3"
	save_state="y"
	sequence="1"
   >
<description trim="y">
<![CDATA[
sfh
Description:
Commands:
Future Ideas:
*	Detect current room and highlight the correct street to fixing
*	Tap into minimap to calculate how many rooms away each of the streets to fix are currently
*	Window-ise the display so that it's visible all of the time

Versions:
1.3	-	Stock check of pavers in inventory. Helpfile/description makeover.
1.2	-	Added colours back into areas
1.1	-	Ability to clear already selected area
1.0	-	Original release

]]>
</description>

</plugin>

<!--  Triggers  -->

<triggers>
  <trigger
   custom_colour="15"
   enabled="y"
   group="streets"
   match="^You finish placing the last (.*?)$"
   regexp="y"
   sequence="100"
   sound="..\Sounds\aaaah.wav"
  >
  </trigger>
  <trigger
   custom_colour="15"
   enabled="y"
   group="streets"
   match="^This section of the street includes (.*?)\. (.*?)to be replaced.(.*?)$"
   regexp="y"
   sequence="100"
   sound="..\Sounds\grind.wav"
  >
  </trigger>
  <trigger
   custom_colour="3"
   enabled="y"
   group="streets"
   match="^This job requires a shovel or pickaxe\, a degree of artistic skill\, and replacement pavers\, either cobbles or setts\.  Each location will require a specific type of paver\.$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>
	--Note ("Street Repair End!")
	world.EnableTrigger("StreetLine",false)
  </send>
  </trigger>  <trigger
   custom_colour="3"
   enabled="y"
   group="streets"
   match="^You are tasked with performing street repairs in Ankh-Morpork\.  Go to the locations provided below and repair any damage as necessary\.  You can perform the repairs in any order\.$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>
	--Note ("Street Repair!")
	--tprint (GetPluginVariableList("bfe35205f026786ea1d56e3b"))
	StreetsToRepair = {}
	world.EnableTrigger("StreetLine",true)
  </send>
  </trigger>
  <trigger
   name="StreetLine"
   custom_colour="3"
   enabled="n"
   group="streets"
   match="^\[(.*?)\] (.*?)\) Replace (.*?) damaged (sett|setts|cobble|cobbles) (.*?) located at (.*?)\.$"
   regexp="y"
   omit_from_output="y"
   send_to="12"
   sequence="100"
   script="ProcessStreetLines"
  >
  </trigger>
</triggers>

<!--  Script  -->


<script>
<![CDATA[
	require ("tprint")
	require "serialize"
	function ProcessStreetLines (name,line,wildcards)
				
		if (locations == nil) then
			locations = {}
			Note ("Resetting locations")
		end -- if
		--Note (location)
		--tprint (locations [location])
		--tprint (wildcards)
		
		local location = string.gsub(wildcards[6],"^the ","")
		--Note ("Location: " .. location)
		local complete = wildcards[1]
		--Note (complete)
		local item = wildcards[2]
		local number = GetNumber (wildcards[3])
		local type = wildcards[4]
		tprint (StreetsToRepair)
		--Note ("Item: " .. item .. ", Number: " .. number .. ", Type: " .. type)
		--tprint (locations)
		local found = false
		for k, v in pairs (locations) do
			--Note (k, v)
			if k == location then
				found = true
			end -- if
		end -- for
		if (found == false) then
			--Note ("location for '" .. location .. "' not found")
			locations [location]={name=location,area="",}
		end -- if
		local name = locations [location] ["name"] or "name Not found"
		--Note ("Name: " .. name)
		AreaColours = {
			{name = "TL", colour = "red"},
			{name = "TM", colour = "orange"},
			{name = "TR", colour = "yellow"},
			{name = "CC", colour = "green"},
			{name = "BL", colour = "blue"},
			{name = "BM", colour = "indigo"},
			{name = "BR", colour = "violet"},
			{name = "", colour = "violet"},
		}
		--tprint (AreaColours)
		local sf = Singularise(type) .. " " .. number .. " " .. item
		hyperlinks = {
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=TL)",
				HText = "TL",
			},	
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=TM)",
				HText = "TM",
			},	
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=TR)",
				HText = "TR",
			},	
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=CC)",
				HText = "CC",
			},	
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=BL)",
				HText = "BL",
			},	
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=BM)",
				HText = "BM",
			},	
			{
				HAction = "!!" .. world.GetPluginID() .. ":AddArea(" .. location .. "=BR)",
				HText = "BR",
			},	
		}
		

		
		if (complete == " ") then
			ColourTell ("black","red","ToDo ")
		else
			ColourTell ("black","green","Done ")
		end -- if
		ColourTell ("",""," ")
		--Note ("Area: " .. locations [location] ["area"])
		local area = ""
		for k, v in pairs (locations) do
			if (k == location) then
				--tprint (v)
				--Note ("Location: " .. k)
				--Note ("Area: " .. v ["area"])
				area = v ["area"]
			end -- if
		end -- for
		if (area == "") then
			--Note ("'" .. locations [location] ["area"] .. "'")
			ShowLocationHyperlinks (locations [location])
		else
			for k, v in pairs (AreaColours) do
				if locations [location] ["area"] == v ["name"] then
					AreaColour = v ["colour"]
				end -- if
			end -- for
			--ColourTell ("black",AreaColour,locations [location] ["area"])
			---- add hyperlink to location to allow it to be reset
			area = locations [location] ["area"]

			haction = "!!" .. world.GetPluginID() .. ":ClearArea(" .. location .. ")"
			--Note (haction)
			Hyperlink (haction, area, "Clear area", "black", AreaColour, 0)
			
			strN = (tostring (locations[location])) 
			--Note ("'" .. locations [location] ["area"] .. "'")
			--Note (location)
			ColourTell ("",""," ")
		end -- if

		Hyperlink ("minimap " .. location, "Minimap","","blue","green")
		ColourTell ("",""," ")
		Hyperlink (sf, "Fix Street","","blue","green")
		ColourTell ("",""," " .. location .. " " .. sf)
		--StreetsToRepair [location]={"name"=[location],"complete"=[complete],"type"=type,"number"=number,"item"=item,area"=area}
		
	end -- function
	function ClearArea(area)
		--Note (locations [area])
		--Note (locations [location] ["area"] )	
		result = utils.msgbox ("Remove area for " .. area .. "?", "Clear Area", "yesno", "?")
		--Note (result)

		if ( result == "yes") then
			--Note (locations [area] ["area"] )
			locations [area] ["area"] = ""
			Execute ("read writ")
		end -- if
		
	end -- function ClearArea
	function OnHelp ()
	  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
	end
	function showtable()
		if (locations ~= nil) then
			tprint (locations)
		else
			Note ("Table locations did not exist. Creating it.")
			locations = {}
		end -- if
		
	end -- function showtable
	
	function OnPluginSaveState ()
		SetVariable ("locations", "locations = " .. serialize.save_simple (locations))
	end -- function
	
	function OnPluginInstall ()
		OnHelp()
	  win = "win" .. GetPluginID ()
	  font_id = "fn"
	  bold_font_id = "fb"
	  
	  font_name = "Sylfaen"    -- the actual font
	  font_size = 8

	  -- make window so I can grab the font info
	  WindowCreate (win, 
					0, 0, 0, 0,  -- empty window
					miniwin.pos_top_left,   -- position (irrelevant)
					0,   -- flags (none)
					0)   -- background colour (black - irrelevant)
					
	  -- add font in normal and bold styles                 
	  WindowFont (win, font_id, font_name, font_size, 
				  false, false, false, false,  -- normal
				  miniwin.font_charset_ansi, miniwin.font_family_any)
				  
	  WindowFont (win, bold_font_id, font_name, font_size, 
				  true, false, false, false,   -- bold
				  miniwin.font_charset_ansi, miniwin.font_family_any)
	  
	  -- find height of font for future calculations             
	  font_height = WindowFontInfo (win, font_id, 1)  -- height
	  -- Add hotspot for window move
		WindowAddHotspot(win, "dragwindow",  
				   0, 0, 20, 20, 
				   "", -- mouseover (do nothing)
				   "", -- cancelmouseover (do nothing)
				   "dragmousedown",
				   "", -- cancelmousedown (do nothing)
				   "", -- mouseup (do nothing)
				   hint,    -- hint text if they hover over it              
				   miniwin.cursor_hand, 0)
		assert (loadstring (GetVariable ("locations") or "")) ()
	end -- function
	
	function MakeHyperlink(HAction, HText)  
	  world.Hyperlink (HAction,HText,HText,"blue","green", 0)
	  ColourTell("",""," ")
	end -- function

	function ShowLocationHyperlinks (location)
	  --Note ("Area: " .. locations[location])
	  --tprint (locations)
	  for k, v in pairs (hyperlinks) do
		--Note (k)
		--Note (v ["HAction"])
		--Note (v ["HText"])
		MakeHyperlink (v ["HAction"], v ["HText"])
	  end -- for

	end -- function
	
	function DisplayStreets ()
		WindowCreate (win, 0, 0, columns * 50, rows * 50, miniwin.pos_center_all, 0, ColourNameToRGB("white"))
		FontColour = ColourNameToRGB("green")
		WindowFont (win, "f", "Trebuchet MS", 12, true, false, false, false) -- define font
		
	end -- function



	function AddArea (locationarea)
		--Note ("Adding area!")
		l = utils.split (locationarea, "=")
		local location = l[1]
		local area = l[2]
		--Note ("Location to add to: " .. location)
		--Note ("Area to add:" .. area)
		--Note (locations [location] ["area"])
		for k, v in pairs (locations) do
			if (k == location) then
				v ["area"] = area
				--Note ("Area: " .. v ["area"])
			end -- if
		end -- for
		locations [location] ["area"] = area
		--tprint (locations)
		Execute ("read writ")
	end -- function
	
	function GetNumber(number)
		numberstable={
		  ["one"]="1",
		  ["two"]="2",
		  ["three"]="3",
		  ["four"]="4",
		  ["five"]="5",
		  ["six"]="6"}
	  return numberstable[number]
	end -- function

	function Singularise(word)
	  if (string.match (word, "sett")) then
		action = "sfs"
	  else
		action = "sfc"
	  end -- if
	  return action
	end -- function
	function checkstock()
		Execute ("frimble Checking setts and cobbles in inventory")
		-- create temp alias to check inventory for cobbles and setts
		
		-- enable triggers
		
		-- invoke temp alias 
	end -- function checkstock
]]>
</script> 



<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="sfh:help"
   enabled="y"
  >
  </alias>
  <alias
   script="showtable"
   match="sfh:showtable"
   enabled="y"
  >
  </alias>
  <alias
   script="checkstock"
   match="sfh:checkstock"
   enabled="y"
  >
  </alias>
  
</aliases>

</muclient>
